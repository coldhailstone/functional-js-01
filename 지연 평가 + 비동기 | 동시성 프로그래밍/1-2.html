<script src="../lib/fx.js"></script>

## 지연된 함수열을 병렬적으로 평가하기 - C.reduce, C.take
<script>
    const C = {};
    function noop() {}
    const catchNoop = arr =>
        (arr.forEach(a => a instanceof Promise ? a.catch(noop) : a), arr);

    C.reduce = curry((f, acc, iter) => {
        let iter2 = catchNoop(iter ? [...iter] : [...acc]);
        return iter 
            ? reduce(f, acc, iter2)
            : reduce(f, iter2);
    });

    C.take = curry((l, iter) => take(l, catchNoop([...iter])));

    C.takeAll = C.take(Infinity);

    C.map = curry(pipe(L.map, C.takeAll));

    C.filter = curry(pipe(L.filter, C.takeAll));

    const delay500 = a => new Promise(resolve =>
        setTimeout(() => resolve(a), 500));

    console.time('');
    go(
        [1, 2, 3, 4, 5, 7, 8, 9],
        L.map(a => delay500(a * a)),
        L.filter(a => delay500(a % 2)),
        L.map(a => delay500(a * a)),
        // C.take(2),
        C.reduce(add),
        log,
        _ => console.timeEnd('')
    );
</script>

## 즉시 병렬적으로 평가하기 - C.map, C.filter
<script>
    C.map(a => delay500(a * a), [1, 2, 3, 4]).then(log);
    C.filter(a => delay500(a % 2), [1, 2, 3, 4]).then(log);
</script>

## 즉시, 지연, Promise, 병렬적 조합하기
<script>
    console.time('f');
    go(
        [1, 2, 3, 4, 5, 7, 8],
        L.map(a => delay500(a * a)),
        L.filter(a => delay500(a % 2)),
        L.map(a => delay500(a * a)),
        C.take(2),
        // C.reduce(add),
        log,
        _ => console.timeEnd('f')
    );
</script>